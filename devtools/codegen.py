import os.path
import sys
import re
import time

# This script is pretty jank, but it should be somewhat usable.

def prepare_path(path):
	# check if this is being run from the /src/ directory or project root
	if not "/src" in path:
		path = path + "/src/"
	
	# strip file extension
	if path.endswith(".h") or path.endswith(".cpp"):
		path = path.removesuffix(".h")
		path = path.removesuffix(".cpp")
		
	if not path.endswith("/") and not path.endswith("\\"):
		path = path + '/'
	
	return path

def find_project_root(path):
	path = path.replace("\\", "/")
	path = path.split("/src")
	return path[0]
	
def make_file(name):
	path = prepare_path(os.getcwd()) + name.replace("-", "")
	
	# check if file already generated
	is_h = os.path.isfile(path + ".h")
	is_cpp = os.path.isfile(path + ".cpp")
	
	if is_h:
		print("File", path + ".h", "already exists!")
		sys.exit()
		
	if is_cpp:
		print("File", path + ".cpp", "already exists!")
		sys.exit()
	
	accept = input("Create file " + path + ".h? [y/n]\n")
	
	if accept != "y":
		print("Cancelling...")
		sys.exit()
	
	register_name = name.lower()
	class_name = ""
	file_name = name.replace("-", "")
	
	for str in name.split('-'):
		class_name = class_name + str.lower().capitalize()
	
	header = f"""
// Generated by Tramway SDK Code generator

#include <framework/entity.h>
#include <framework/serialization.h>

#include <templates/macros.h>

using namespace tram;

class {class_name} : public Entity {{
public:
	{class_name}(const SharedEntityData&, const ValueArray&);

	TRAM_SDK_ENTITY_NAME("{register_name}")
	
	void UpdateParameters();
	void SetParameters();
	void Load();
	void Unload();
	void Serialize();
	void EventHandler(Event& evt);
	void MessageHandler(Message& msg);
	name_t GetType();
	static void Register();
}};
	"""
	
	implementation = f"""
// Generated by Tramway SDK Code generator

#include "{file_name}.h"
#include "{file_name}.inl"

#include <framework/event.h>
#include <framework/message.h>
	
{class_name}::{class_name}(const SharedEntityData& shared_data, const ValueArray& field_array) : Entity(shared_data) {{
	ENTITY_IMPLEMENTATION_INITIALIZE
}}

void {class_name}::Register() {{
    ENTITY_IMPLEMENTATION_REGISTER
}}

name_t {class_name}::GetType() {{
    ENTITY_IMPLEMENTATION_GET_TYPE
}}

void {class_name}::UpdateParameters() {{
	if (!IsLoaded()) return;
}}

void {class_name}::SetParameters() {{
	if (!IsLoaded()) return;
	
	UpdateParameters();
}}

void {class_name}::Load() {{
	SetFlag(LOADED, true);
}}

void {class_name}::Unload() {{
	SetFlag(LOADED, false);
}}

void {class_name}::Serialize() {{

}}

void {class_name}::EventHandler(Event& evt) {{

}}

void {class_name}::MessageHandler(Message& msg) {{

}}
	"""
	
	open(path + ".h", "w").write(header)
	open(path + ".cpp", "w").write(implementation)
	
	print("Done!")
	
	#print(header)
	#print(implementation)
	
def enumify(str):
	return "FIELD_" + str.replace("-", "_").upper().strip().replace("\"", "")
	
def typeify(str):
	if str == "name_t":
		return "TYPE_NAME"
		
	if str == "bool":
		return "TYPE_BOOL"
	if str == "int":
		return "TYPE_INT32"
		
	if str == "float":
		return "TYPE_FLOAT32"
	if str == "double":
		return "TYPE_INT32"
		
	if str == "int8_t":
		return "TYPE_INT8"
	if str == "int16_t":
		return "TYPE_INT16"
	if str == "int32_t":
		return "TYPE_INT32"
		
	if str == "uint8_t":
		return "TYPE_UINT8"
	if str == "uint16_t":
		return "TYPE_UINT16"
	if str == "uint32_t":
		return "TYPE_UINT32"

	if str == "vec2":
		return "TYPE_VEC2"
	if str == "vec3":
		return "TYPE_VEC3"
	if str == "vec4":
		return "TYPE_VEC4"
	if str == "quat":
		return "TYPE_QUAT"

	print("Unrecognized type:", str)
	sys.exit()
	
def enttipefy(str):
	if str == "name_t":
		return "name"
		
	if str == "bool":
		return "bool"
	if str == "int":
		return "int"
		
	if str == "float":
		return "float"
	if str == "double":
		return "float"
		
	if str == "int8_t":
		return "int"
	if str == "int16_t":
		return "int"
	if str == "int32_t":
		return "int"
		
	if str == "uint8_t":
		return "uint"
	if str == "uint16_t":
		return "uint"
	if str == "uint32_t":
		return "uint"

	if str == "vec2":
		return "vec2"
	if str == "vec3":
		return "vec3"
	if str == "vec4":
		return "vec4"
	if str == "quat":
		return "quat"

	print("Unrecognized type:", str)
	sys.exit()
	
def refresh_file(name):
	path = prepare_path(os.getcwd()) + name.replace("-", "")
	
	# check if entity file exists
	if not os.path.isfile(path + ".h"):
		print("File", path + ".h", "not found!")
		sys.exit()
		
	file = open(path + ".h", "r").read()
	
	property_list = []
	
	property_enum = ""
	initializer = ""
	register = ""
	
	# use regex to find stuff
	name_list = re.findall("TRAM_SDK_ENTITY_NAME\((.*)\)", file)
	if len(name_list) < 1:
		print("Couldn't find TRAM_SDK_ENTITY_NAME macro!")
		sys.exit()
		
	class_list = re.findall("class\s+(.*)\s+:\s+public\s+Entity", file)
	if len(name_list) < 1:
		print("Couldn't find class name!")
		sys.exit()
	
	key_values = re.findall("TRAM_SDK_KEY_VALUE\((.*),(.*)\)", file)
	
	# parse properties
	properties = re.findall("TRAM_SDK_PROPERTY\((.*),(.*)\)\s+(\S+)\s+(\S+)\s*(?:=.*?)?;", file)
	for property in properties:
		property_list.append({
			"name": property[0],
			"type": property[2],
			"flags": property[1],
			"variable": property[3]
		})
	
	properties = re.findall("TRAM_SDK_VIRTUAL_PROPERTY\((.*),(.*),(.*)\)", file)
	for property in properties:
		property_list.append({
			"name": property[1],
			"type": property[0],
			"flags": property[2],
			"variable": None
		})
	
	# generate property enum
	
	for property in property_list:
		if property_enum != "":
			property_enum += ",\n"
		
		property_enum += "\t" + enumify(property["name"])
		
	if property_enum == "":
		property_enum = "FIELD_NONE"
	
	# generate initializer
	for property in property_list:
		if property["variable"] is None:
			continue
			
		if initializer != "":
			initializer += " \\\n"
		
		initializer += "\t" + property["variable"] + " = field_array[" + enumify(property["name"]) + "];" 
	
	# generate register
	for property in property_list:
		if register != "":
			register += ", \\\n"
		
		register += "\t{" + enumify(property["name"]) + ", " + typeify(property["type"]) + ", " + property["flags"] + "}" 
	
	generated = f"""
// Generated by Tramway SDK Code generator
// READ ONLY! Any and all changes will be overwritten!
	
enum {{
{property_enum}
}};

#define ENTITY_IMPLEMENTATION_INITIALIZE \\
{initializer}

#define ENTITY_IMPLEMENTATION_REGISTER  \\
Entity::RegisterType( \\
	{name_list[0]},  \\
	[](const SharedEntityData& a, const ValueArray& b) -> Entity* {{ return new {class_list[0]}(a, b); }}, \\
	[](Entity* a) {{ delete a; }}, \\
	{{ \\
{register} \\
	}} \\
);

#define ENTITY_IMPLEMENTATION_GET_TYPE return {name_list[0]};

	"""
	
	
	key_value_str = ""
	field_str = ""
	
	for key_value in key_values:
		key_value_str += "\t" + key_value[0].replace("\"", "") + " " + key_value[1].replace("\"", "")
	
	for property in property_list:
		field_str += "\tfield " + enttipefy(property["type"]) + " " + property["name"].replace("\"", "") + "\n"
	
	entity_name = name_list[0].replace("\"", "").strip()
	version_num = str(int(time.time()) - 1577836800)
	
	entity_definition = f"""
begin
	name {entity_name}
	
{key_value_str}
	
{field_str}
	
	version {version_num}
end
	
	"""
	
	open(path + ".inl", "w").write(generated)
	open(find_project_root(path) + f"/data/{entity_name}.{version_num}.entdef", "w").write(entity_definition)
	
	#
	
	print("Done!")
	
	
def print_header():
	print("Tramway SDK Code generator v0.1.0")

def print_help():
	print("This tool can generate C++ code for the Tramway SDK.")
	print("Commandline options:")
	print("\t--help\t\tPrints this message")
	print("\tmake [name]\tGenerates a .h and .cpp file for an entity type")
	print("\trefresh [file]\tRegenerates code and entity definition from header file")
	print("\t[file]\t\tSame as 'refresh' option")

if len(sys.argv) > 1:
	command = sys.argv[1]
	parameter = sys.argv[2] if len(sys.argv) > 2 else None
	
	if command == "make":
		print_header()
		
		if parameter is None:
			print("To use this command, specify the name of the entity type that will be")
			print("generated. This name will be used as the name of the entity type, name of the")
			print("entity C++ class, and the name of the source code files.")
			print("")
			print("For example, if you use 'bucket' as the name of the entity type, the resulting")
			print("code will be generated in the /src/bucket.h and /src/bucket.cpp files, the name")
			print("of the C++ class will be named 'Bucket' and the name inserted into the")
			print("Register() method will be 'bucket'.")
			print("")
			print("Example: codegen.py make bucket")
			
			sys.exit()
		
		
		
		print("making! ", command, parameter)
		
		make_file(parameter)
	elif command == "refresh":
		print_header()
		refresh_file(parameter)
	elif command == "--help":
		print_header()
		print_help()
	else:
		print("Unrecognized command:", command)
else:
	print_header()
	print_help()
	
