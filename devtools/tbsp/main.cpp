// TRAMWAY DRIFT AND DUNGEON EXPLORATION SIMULATOR 2022
// All rights reserved.

// Tramway SDK -- Map converter

// TODO:

// - mesh simplification(?) sometimes generates edges with NaN vertices
//		- this is not good and should be fixed.

#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

#include <framework/logging.h>
#include <framework/file.h>
#include <framework/math.h>

#include <stb_image.h>

using namespace tram;

struct Vertex {
	vec3 pos;
	vec3 nrm;
	vec2 tex;
	vec2 map;
};

struct Triangle {
	uint32_t v1, v2, v3;
	uint32_t mat;
};

struct Material {
	std::string name;
	int width, height;
};

struct Plane {
	float x_offset, y_offset;
	float x_scale, y_scale;
	float rotation;
	
	vec3 p1, p2, p3;
	
	std::string material;
};

struct Edge {
	vec3 p1, p2;
};

struct Polygon {
	std::vector<Edge> edges;
	Plane plane;
};

struct Brush {
	std::vector<Plane> planes;
	std::vector<Polygon> polys;
	
	std::vector<vec3> hull;
};

struct Entity {
	std::vector<Brush> brushes;
	std::string name;
};

vec4 PlaneToEquation(const Plane& plane) {
	vec3 dir1 = plane.p2 - plane.p1;
	vec3 dir2 = plane.p3 - plane.p1;
	vec3 cros = glm::normalize(glm::cross(dir1, dir2));
	
	float dist = glm::dot(cros, plane.p1);
	
	return {cros, -dist};
}

// returns 0 if needs clipped, -1 if thrown away, 1 if kept
int NeedsClipped(Polygon poly, vec4 eq, float bias = 0.0f) {
	int inside_vertices = 0;
	int outside_vertices = 0;

	for (auto& edge : poly.edges) {
		float dist1 = glm::dot(vec3(eq), edge.p1) + eq.w;
		float dist2 = glm::dot(vec3(eq), edge.p2) + eq.w; 

		if (dist1 < bias) outside_vertices++; else inside_vertices++;
		if (dist2 < bias) outside_vertices++; else inside_vertices++;
	}

	//std::cout << inside_vertices <<  " " << outside_vertices << std::endl;

	static int i =0;
	i++;

	if (outside_vertices == 0) {
		return 1;
	}

	if (inside_vertices == 0) {
		return -1;
	}
	
	return 0;
}

std::pair<Polygon, Edge> Clip(Polygon poly, vec4 eq) {
	std::vector<Edge> new_edges;
	Edge new_edge = {{INFINITY, INFINITY, INFINITY}, {0, 0, 0}};
	for (auto& edge : poly.edges) {
		float dist1 = glm::dot(vec3(eq), edge.p1) + eq.w;
		float dist2 = glm::dot(vec3(eq), edge.p2) + eq.w;
		
		//std::cout << "p1: " << edge.p1.x << " " << edge.p1.y << " " << edge.p1.z << std::endl;
		//std::cout << "p2: " << edge.p2.x << " " << edge.p2.y << " " << edge.p2.z << std::endl;
		
		//std::cout << "dist1: " << dist1 << "dist2: " << dist2 << std::endl;
		
		if (dist1 < 0.0f && dist2 < 0.0f) {
			//std::cout << "skipping" << std::endl;
			continue;
		}
		
		if (dist1 < 0.0f) {
			//std::cout << "clipping p1" << std::endl;
			
			vec3 l0 = edge.p1;
			vec3 l = glm::normalize(edge.p2 - edge.p1);
			vec3 n = vec3(eq);
			vec3 p0 = n * -eq.w;
			float d = glm::dot((p0-l0), n) / glm::dot(l, n);
			edge.p1 = l0 + l*d;
			
			
			if (new_edge.p1.x == INFINITY) {
				new_edge.p1 = edge.p1;
			} else {
				new_edge.p2 = edge.p1;
				new_edges.push_back(new_edge);
				//new_polygon.edges.push_back(new_edge);
				//std::cout << "n1: " << new_edge.p1.x << " " << new_edge.p1.y << " " << new_edge.p1.z << std::endl;
				//std::cout << "n2: " << new_edge.p2.x << " " << new_edge.p2.y << " " << new_edge.p2.z << std::endl;
			}
		}
		
		if (dist2 < 0.0f) {
			//std::cout << "clipping p2" << std::endl;
			
			//edge.p2 -= vec3(eq) * dist2; // TODO: fix
			
			
			vec3 l0 = edge.p1;
			vec3 l = glm::normalize(edge.p2 - edge.p1);
			vec3 n = vec3(eq);
			vec3 p0 = n * -eq.w;

			float d = glm::dot((p0-l0), n) / glm::dot(l, n);

			edge.p2 = l0 + l*d;
			
			if (new_edge.p1.x == INFINITY) {
				new_edge.p1 = edge.p2;
			} else {
				new_edge.p2 = edge.p2;
				
				//std::swap(new_edge.p1, new_edge.p2);
				
				new_edges.push_back(new_edge);
				//new_polygon.edges.push_back(new_edge);
				//std::cout << "n1: " << new_edge.p1.x << " " << new_edge.p1.y << " " << new_edge.p1.z << std::endl;
				//std::cout << "n2: " << new_edge.p2.x << " " << new_edge.p2.y << " " << new_edge.p2.z << std::endl;
			}
		}
		
		new_edges.push_back(edge);
		
		//std::cout << dist1 << " ";
	}
	poly.edges = new_edges;
	return {poly, new_edge};
}

int main(int argc, const char** argv) {
	SetSystemLoggingSeverity(System::SYSTEM_PLATFORM, SEVERITY_WARNING);

	std::cout << "Tramway SDK -- Map converter" << std::endl;
	
	std::vector<Entity> entities;
	
	// + --------------------------------------------------------------------- +
	// |                                                                       |
	// |                               MAP LOADER                              |
	// |                                                                       |
	// + --------------------------------------------------------------------- +
	
	// This part is pretty simple -- first we load the map file into memory,
	// then we parse it. The file format itself consists of text. 

	// This parser implementation is pretty bad and might not work with map 
	// files generated by all programs.
	
	File file("paliktnis.map", MODE_READ | MODE_PAUSE_LINE);
	
	if (!file.is_open()) {
		std::cout << "Error OPENING to model file " << "w" << std::endl;
		return 0;
	}
	
	//int i = 0;
	while (file.cursor < file.cursor_end) {
		
		// comment. skip until end of line
		if (*file.cursor == '/') {
			while (*file.cursor != '\n'/* || *file.cursor != '\0'*/) {
				file.cursor++;
			}
			file.cursor++;
			
			continue;
		}
		
		// start of an entity
		if (*file.cursor == '{') {
			Entity entity;
			
			*file.cursor++; // skip opening bracket
			
			// read in parameters of the entity
			for (;;) {
				
				// find parameter name opening bracket
				while (*file.cursor != '"' && *file.cursor != '{') file.cursor++;
				
				// we reached the part where the brush planes are defined
				if (*file.cursor == '{') break;
				
				file.cursor++; // skip opening quote
				
				char parameter[256];
				char value[256];
				
				// copy in parameter
				for (char* p = parameter; *file.cursor != '"'; p++ && file.cursor++) {
					p[0] = *file.cursor;
					p[1] = '\0';
				}
				
				file.cursor++; 								// skip closing quote
				while (*file.cursor != '"') file.cursor++; 	// find next quote
				file.cursor++;								// skip opening quote
				
				// copy in value
				for (char* v = value; *file.cursor != '"'; v++ && file.cursor++) {
					v[0] = *file.cursor;
					v[1] = '\0';
				}
				
				file.cursor++;  // skip closing quote
				
				if (std::string(parameter) == "classname" && std::string(value) == "worldspawn") {
					entity.name = "worldspawn";
				}
				
				if (std::string(parameter) == "_tb_name") {
					entity.name = value;
				}
			}
			
			// reading in brushes
			for (;;) {
				while(*file.cursor != '{' && *file.cursor != '}') file.cursor++;
				
				if (*file.cursor == '}') break;
				
				Brush brush;
				
				// read in all the planes
				for (;;) {
					vec3 points[3];
					
					// read in planes
					for (int i = 0; i < 3; i++) {
						while (*file.cursor != '(') file.cursor++;
						file.cursor++;
						
						points[i].x = atof(file.cursor);
						while (isspace(*file.cursor)) file.cursor++;
						while (!isspace(*file.cursor)) file.cursor++;
						points[i].y = atof(file.cursor);
						while (isspace(*file.cursor)) file.cursor++;
						while (!isspace(*file.cursor)) file.cursor++;
						points[i].z = atof(file.cursor);
					}
					
					Plane plane;
					
					plane.p1 = points[0];
					plane.p2 = points[1];
					plane.p3 = points[2];
					
					char material[256];
					
					while (*file.cursor != ')') file.cursor++;
					file.cursor++;
					while (isspace(*file.cursor)) file.cursor++;
					
					// copy in material name
					for (char* m = material; !isspace(*file.cursor); m++ && file.cursor++) {
						m[0] = *file.cursor;
						m[1] = '\0';
					}
					
					plane.material = material;
					
					plane.x_offset = atof(file.cursor);
					while (isspace(*file.cursor)) file.cursor++;
					while (!isspace(*file.cursor)) file.cursor++;
					plane.y_offset = atof(file.cursor);
					while (isspace(*file.cursor)) file.cursor++;
					while (!isspace(*file.cursor)) file.cursor++;
					plane.rotation = atof(file.cursor);
					while (isspace(*file.cursor)) file.cursor++;
					while (!isspace(*file.cursor)) file.cursor++;
					plane.x_scale = atof(file.cursor);
					while (isspace(*file.cursor)) file.cursor++;
					while (!isspace(*file.cursor)) file.cursor++;
					plane.y_scale = atof(file.cursor);
					while (isspace(*file.cursor)) file.cursor++;
					while (!isspace(*file.cursor)) file.cursor++;
					
					brush.planes.push_back(plane);
					
					while (isspace(*file.cursor)) file.cursor++;
					
					if (*file.cursor == '}') {
						*file.cursor++;
						break;
					}
				}
				
				entity.brushes.push_back(brush);
			}

			entities.push_back(entity);
		}
		
		file.cursor++;
	}
	
	// + --------------------------------------------------------------------- +
	// |                                                                       |
	// |                            POLYGON CONVERTER                          |
	// |                                                                       |
	// + --------------------------------------------------------------------- +
	
	// Now that the map has been parsed and loaded into memory, it is time to
	// convert the brushes (which are defined as planes), into polygons, which 
	// we can use later for rendering.
	
	// For each brush we will initially create a very large polygonal cube. Then
	// we will start clipping it with each brush plane, until we have clipped it
	// into the shape of the brush.
	
	const vec3 low_lft_bak = {-1000.0f, -1000.0f, -1000.0f};
	const vec3 low_rgt_bak = { 1000.0f, -1000.0f, -1000.0f};
	const vec3 low_rgt_frt = { 1000.0f, -1000.0f,  1000.0f};
	const vec3 low_lft_frt = {-1000.0f, -1000.0f,  1000.0f};
	const vec3 hgh_lft_bak = {-1000.0f,  1000.0f, -1000.0f};
	const vec3 hgh_rgt_bak = { 1000.0f,  1000.0f, -1000.0f};
	const vec3 hgh_rgt_frt = { 1000.0f,  1000.0f,  1000.0f};
	const vec3 hgh_lft_frt = {-1000.0f,  1000.0f,  1000.0f};
	
	const Plane blank = {
		0.0f, 0.0f, 0.0f, 0.0f, 0.0f,
		{0.0f, 0.0f, 0.0f},
		{1.0f, 0.0f, 0.0f},
		{0.0f, 1.0f, 0.0f},
		"none"
	};
	
	const std::vector<Polygon> initial {
		{{{low_lft_bak, hgh_lft_bak}, {hgh_lft_bak, hgh_rgt_bak}, {hgh_rgt_bak, low_rgt_bak}, {low_rgt_bak, low_lft_bak}}, blank},
		{{{low_rgt_bak, hgh_rgt_bak}, {hgh_rgt_bak, hgh_rgt_frt}, {hgh_rgt_frt, low_rgt_frt}, {low_rgt_frt, low_rgt_bak}}, blank},
		{{{low_rgt_frt, hgh_rgt_frt}, {hgh_rgt_frt, hgh_lft_frt}, {hgh_lft_frt, low_lft_frt}, {low_lft_frt, low_rgt_frt}}, blank},
		{{{low_lft_frt, hgh_lft_frt}, {hgh_lft_frt, hgh_lft_bak}, {hgh_lft_bak, low_lft_bak}, {low_lft_bak, low_lft_frt}}, blank},
		{{{low_lft_bak, low_rgt_bak}, {low_rgt_bak, low_rgt_frt}, {low_rgt_frt, low_lft_frt}, {low_lft_frt, low_lft_bak}}, blank},
		{{{hgh_lft_bak, hgh_lft_frt}, {hgh_lft_frt, hgh_rgt_frt}, {hgh_rgt_frt, hgh_rgt_bak}, {hgh_rgt_bak, hgh_lft_bak}}, blank},
	};
	
	Entity& ent = entities[0];
	std::cout << "printing " << ent.name << std::endl;
	
	int toot = 0;
	
	for (auto& brush : ent.brushes) {
		// make initial polygonal mega-cube
		brush.polys = initial;
		
		int yeet = 0;
		toot++;
		
		std::cout << "BRUSH " << toot << std::endl;
		
		// clip it down with brush planes
		for (auto& plane : brush.planes) {
			std::vector<Polygon> clipped_polys;
			
			vec4 eq = PlaneToEquation(plane);
			std::cout << eq.x << " " << eq.y << " " << eq.z << " " << eq.w << std::endl;
			
			
			Polygon new_polygon = {.plane = {.material="none"}}; // may or may not be filled
			
			yeet++;
			
			for (auto& poly : brush.polys) {
				if (yeet > 6 && toot != 1) {
					/*if (poly.plane.material != "none")*/ clipped_polys.push_back(poly);
					continue;
				}
				
				int needs_clipped = NeedsClipped(poly, eq);
				if (needs_clipped == 1) {
					clipped_polys.push_back(poly);
					std::cout << "kept" << std::endl;
					continue;
				}
				
				if (needs_clipped == -1) {
					//clipped_polys.push_back(poly);
					std::cout << "skip" << std::endl;
					continue;
				}
				
				std::cout << "clip" << std::endl;
				
				auto[clipped_poly, new_edge] = Clip(poly, eq);
				
				clipped_polys.push_back(clipped_poly);
				new_polygon.edges.push_back(new_edge);
				
				/*for (auto& edge : poly.edges) {
					float dist1 = glm::dot(vec3(eq), edge.p1) + eq.w;
					float dist2 = glm::dot(vec3(eq), edge.p2) + eq.w;
					
					if (dist1 < 0.0f) edge.p1 -= vec3(eq) * dist1;
					if (dist2 < 0.0f) edge.p2 -= vec3(eq) * dist2;
					
					std::cout << dist1 << " ";
				}*/
			}
			
			std::cout << "new poly: " << new_polygon.edges.size() << std::endl;
			
			/*auto plane_id = plane_eq_to_plane.find(eq);
			
			if (plane_id == plane_eq_to_plane.end()) {
				int id = planes.size();
				planes.push_back(plane);
				plane_eq_to_plane[eq] = id;
				new_polygon.plane = id;
			} else {
				new_polygon.plane = *plane_id;
			}*/

			new_polygon.plane = plane;
			
			clipped_polys.push_back(new_polygon);
			
			brush.polys = clipped_polys;
			
			std::cout << std::endl;
			//break;
		}
		
		//for (auto& poly : brush_polys) {
			//mesh.push_back(poly);
		//}
		
		//break;
		
		/*std::cout << "new" << std::endl;
		for (auto& p : brush.planes) {
			std::cout << p.p1.x << " " << p.p1.y << " " << p.p1.z << " ";
			std::cout << p.p2.x << " " << p.p2.y << " " << p.p2.z << " ";
			std::cout << p.p3.x << " " << p.p3.y << " " << p.p3.z << " ";
			std::cout << p.material << std::endl;
		}*/
		
		//break;
	}

	// + --------------------------------------------------------------------- +
	// |                                                                       |
	// |                         HIDDEN SURFACE REMOVAL                        |
	// |                                                                       |
	// + --------------------------------------------------------------------- +
	
	int miss = 0;
	int pass = 0;
	
	std::vector<Brush> new_brushes;
	
	// iterate through all brushes of an entity
	for (auto& brush : ent.brushes) {
		Brush new_brush = {.planes = brush.planes};
		
		// then iterate through all polygons of a brush
		for (auto& poly : brush.polys) {
			
			// compute the plane equation of the polygon
			vec4 eq = PlaneToEquation(poly.plane);
			
			// now find all of the brushes that are adjacent to the polygon
			std::vector<Brush*> adjacent;
			
			for (auto& brush_clip : ent.brushes) {
				if (&brush == &brush_clip) continue;
				
				bool shared_plane = false;
				
				for (auto& poly_clip : brush_clip.polys) {
					bool on_plane = true;
					
					for (auto& edge_clip : poly_clip.edges) {
						if (abs(glm::dot(vec3(eq), edge_clip.p1) + eq.w) > 0.1f ||
							abs(glm::dot(vec3(eq), edge_clip.p2) + eq.w) > 0.1f
						) {
							//std::cout << "glm::dot(eq1, eq2) " << glm::dot(eq1, eq2) << std::endl;
							
							//if (glm::dot(eq1, eq2) > 0.0f) {
								on_plane = false;
							//}
						}
					}
					
					if (on_plane) {
						vec4 poly_eq = PlaneToEquation(poly_clip.plane);
							
						vec3 eq1 = eq;
						vec3 eq2 = poly_eq;
						
						if (glm::dot(eq1, eq2) < 0.0f) {
							shared_plane = true;
						}
						
					}
				}
				
				if (shared_plane) {
					adjacent.push_back(&brush_clip);
					pass++;
				} else {
					miss++;
				}
			}
			
			if (adjacent.size()) {
				//poly.plane.material="dev/nodraw";
			}
			
			std::vector<Polygon> soup = {poly};
			//new_brush.polys.push_back(poly);
			
			int clips = 0;
			
			for (Brush* brush_clip : adjacent) {
				std::vector<Polygon> new_soup;
				
				for (auto& soup_poly : soup) {
					std::vector<Polygon> speculative_soup;
					Polygon remainder = soup_poly;
					bool clipped = false;
					bool what_the_fuck = false;
					
					for (auto& plane : brush_clip->planes) {
						vec4 plane_eq = PlaneToEquation(plane);

						// this skips planes that have the same plane as polygon
						if (abs(glm::dot(vec3(eq), vec3(plane_eq))) >0.9f) continue;
						
						
						int needs_clipped = NeedsClipped(remainder, plane_eq, 0.1f);
						
						if (needs_clipped == -1) {
							std::cout << "what the fuck" << std::endl;
							what_the_fuck = true;
							continue;
						}
						
						if (needs_clipped == 1) {
							clipped = true;
							continue;
						}
						
						std::cout << "clipping" << std::endl;
						
						//continue;
						
						clipped = true;
						
						auto clipped_off = Clip(remainder, -plane_eq);
						auto new_remainder = Clip(remainder, plane_eq);
						
						speculative_soup.push_back(clipped_off.first);
						remainder = new_remainder.first;
						
					
					}
					
					if (what_the_fuck) {
						new_soup.push_back(soup_poly);
						continue;
					}
					
					if (!clipped /*|| true*/) speculative_soup.push_back(remainder);
					
					for (auto& poly : speculative_soup) {
						new_soup.push_back(poly);
					}

				}
				
				soup = new_soup;
			}
			
			for (auto& soup_polygon : soup) {
				new_brush.polys.push_back(soup_polygon);
			}
			
			/*
			bool yeeted = false;
			Polygon clip_poly = poly;
			for (Brush* brush_clip : adjacent) {
				for (auto& plane : brush_clip->planes) {
					vec4 eq = PlaneToEquation(plane);
					//std::cout << NeedsClipped(poly, eq) << " ";
					
					bool skip = false;
					for (auto& e : clip_poly.edges) {
						if (abs(glm::dot(vec3(eq), e.p1) + eq.w) < 0.1f ||
							abs(glm::dot(vec3(eq), e.p2) + eq.w) < 0.1f
						) {
							skip = true;
						}
					}
					if (skip) continue;
					
					
					auto[new_poly, _] = Clip(clip_poly, eq);
					
					for (auto& e : new_poly.edges) {
						std::cout << e.p1.x << " " << e.p1.y << " " << e.p1.z << " " << " -> " << e.p2.x << " " << e.p2.y << " " << e.p2.z << "; ";
					}
					std::cout << std::endl;
					
					//poly = new_poly;
					new_polys.push_back(clip_poly);
					clip_poly = new_poly;
					
					yeeted = true;
				}
				
				if (yeeted) goto here;
				//std::cout << std::endl;
			}
			
			if (!yeeted) new_polys.push_back(poly);
			
			here:;*/
		}
		
		new_brushes.push_back(new_brush);
	}
	
	ent.brushes = new_brushes;
	
	std::cout << "miss: " << miss << std::endl;
	std::cout << "pass: " << pass << std::endl;
	
	
	// + --------------------------------------------------------------------- +
	// |                                                                       |
	// |                     POLYGON TO TRIANGLE CONVERTER                     |
	// |                                                                       |
	// + --------------------------------------------------------------------- +
	
	// This part here will convert our polygons, which are defined as a set of
	// edges, into little indexed traingles, that can be saved to a disk file.
	
	// First it will find a list of unique materials, then it will load in the
	// dimensions of the textures of these materials, and finally it will 
	// triangulate our polygons, using the texture dimensions to help with
	// texture projection.
	
	std::vector<Material> materials;
	std::vector<Vertex> vertices;
	std::vector<Triangle> indices;
	
	// iterate through all planes and find all of the materials
	for (auto& brush : ent.brushes) {
		for (auto& plane : brush.planes) {
			bool already_in_list = false;
			for (int i = 0 ; i < materials.size(); i++) {
				if (materials[i].name == plane.material) {
					already_in_list = true;
					break;
				}
			}
			
			if (!already_in_list) materials.push_back({.name=plane.material});
		}
	}
	
	// find the parameters of the materials
	for (auto& mat : materials) {
		std::string path = "../../data/textures/";
		path += mat.name;
		path += ".png";
		
		int x, y, n;
		
		if (!stbi_info(path.c_str(), &x, &y, &n)) {
			std::cout << "File " << path << " not found!" << std::endl;
			
			// this is a sane resolution for a texture
			x = 32;
			y = 32;
		}
		
		mat.width = x;
		mat.height = y;
	}
		
	
	auto make_vertex = [](Plane plane, Material mat, vec3 vert, vec3 normal) -> Vertex {
		vec3 pos = vert * (1.0f/32.0f);
		vec2 tex = vec2{vert.x, vert.y} * (1.0f/32.0f);
		
		if (abs(glm::dot(vec3(1.0f, 0.0f, 0.0f), normal))>0.5f) {
			//tex = vec2{vert.y, vert.z} * (1.0f/32.0f);
			tex = vec2{vert.y * (1.0f/(float)mat.width), vert.z * (1.0f/(float)mat.height)};
		}
		
		if (abs(glm::dot(vec3(0.0f, 1.0f, 0.0f), normal))>0.5f) {
			//tex = vec2{vert.x, vert.z} * (1.0f/32.0f);
			tex = vec2{vert.x * (1.0f/(float)mat.width), vert.z * (1.0f/(float)mat.height)};
		}
		
		if (abs(glm::dot(vec3(0.0f, 0.0f, 1.0f), normal))>0.5f) {
			//tex = vec2{vert.x, vert.y} * (1.0f/32.0f);
			tex = vec2{vert.x * (1.0f/(float)mat.width), vert.y * (1.0f/(float)mat.height)};
		}
		
		
		return {
			{pos.x, pos.z, -pos.y},
			{normal.x, normal.z, -normal.y},
			tex,
			tex
		};
	};
	
	for (auto& brush : ent.brushes) {
	for (auto& poly : brush.polys) {
		if (poly.edges.size() < 3) continue;

		
		//vec3 dir1 = glm::normalize(poly_verts[1] - poly_verts[0]);
		//vec3 dir2 = glm::normalize(poly_verts[2] - poly_verts[0]);
		//vec3 normal = glm::normalize(glm::cross(dir1, dir2));
		
		//std::cout << "outputting polygon" << std::endl;
	
		uint32_t mat = 0;
		for (int i = 0 ; i < materials.size(); i++) {
			if (materials[i].name == poly.plane.material) mat = i;
		}
	
		vec3 eq = PlaneToEquation(poly.plane);
		vec3 pivot = poly.edges[0].p1;
		
		uint32_t p0 = vertices.size();
		
		vertices.push_back(make_vertex(poly.plane, materials[mat], pivot, eq));
		


		
		
		int drops = 0;
		
		for (auto& edge : poly.edges) {
			if (edge.p1 == pivot || edge.p2 == pivot) {
				drops++;
				if (drops < 3) continue;
			}
			
			
			uint32_t p1 = vertices.size();
			uint32_t p2 = vertices.size() + 1;
			
			vertices.push_back(make_vertex(poly.plane, materials[mat], edge.p1, eq));
			vertices.push_back(make_vertex(poly.plane, materials[mat], edge.p2, eq));
			
			if (glm::dot(glm::normalize(glm::cross(edge.p1-pivot, edge.p2-pivot)), vec3(eq)) < 0.0f) {
				indices.push_back({p0, p1, p2, mat});
			} else {
				indices.push_back({p0, p2, p1, mat});
			}
			
			
			
			//std::cout << "" << std::endl;

		}
		
		if (drops != 2) {
			std::cout << "AAAAAA" << std::endl;
			//for (auto& edge : poly.edges) {
			//	std::cout << edge.p1.x << " " << edge.p1.y << " " << edge.p1.z << "\t" //<< edge.p2.x << " " << edge.p2.y << " " << edge.p2.z << " " << std::endl;
			//}
		}

		//for (int i = 1; i < poly.edges.size() - 1; i++) {
		//	indices.push_back({v_index, v_index+i, v_index+i+1, 0});
		//}
		
		//for (int i = 1; i < poly_verts.size()-1; i++) {
		//	indices.push_back({v_index, v_index+i, v_index+i+1, 0});
		//}
		
		//std::cout << "AAAAAAAA " << poly_verts.size() <<std::endl;
		
		

		
		
		/*for (int i = 0; i < poly_verts.size()-2; i++) {
			for (int j = 1; j < poly_verts.size()-1; j++) {
				for (int k = 2; k < poly_verts.size(); k++) {
					indices.push_back({v_index+i, v_index+j, v_index+k, (uint32_t)mat});
				}
			}
		}*/
		
	}
	//break;
	}
	
	
	// + --------------------------------------------------------------------- +
	// |                                                                       |
	// |                    POLYGON TO CONVEX HULL CONVERTER                   |
	// |                                                                       |
	// + --------------------------------------------------------------------- +
	
	for (auto& brush : ent.brushes) {
		for (const auto& poly : brush.polys) {
		for (const auto& edge : poly.edges) {
			bool found_p1 = false;
			bool found_p2 = false;
			for (const auto& point : brush.hull) {
				if (point == edge.p1) found_p1 = true;
				if (point == edge.p2) found_p2 = true;
			}
			if (!found_p1 && !std::isnan(edge.p1.x) && !std::isinf(edge.p1.x)) brush.hull.push_back(edge.p1);
			if (!found_p2 && !std::isnan(edge.p2.x) && !std::isinf(edge.p2.x)) brush.hull.push_back(edge.p2);
		}}
		
		for (auto& point : brush.hull) {
			point = {point.x, point.z, -point.y};
			point *= 1.0f/32.0f;
		}
	}
	
	/*
	if (argc < 3) {
		std::cout << "Usage: tmap model size [padding]";
		std::cout << "\n\tmodel is the name of the model, which will be packed";
		std::cout << "\n\tsize is the size of the lightmap, in pixels";
		std::cout << "\n\tpadding is the padding of lightmap segemnts, in pixels";
		return 0;
	}
	
	const char* model_name = argv[1];
	int lightmap_size = atoi(argv[2]);
	int lightmap_padding = argc >= 4 ? atoi(argv[3]) : 2;
	
	if ((lightmap_size & (lightmap_size - 1)) != 0 || lightmap_size < 1) {
		std::cout << "Lightmap size has to be a power of two." << std::endl;
		return 0;
	}*/
	
	/*for (int i = 5; i < argc; i++) {
		if (strcmp(argv[i], "-pack") == 0) {
			packing = true;
		}
	}*/
	
	// +-----------------------------------------------------------------------+
	// +                                                                       +
	// +                             MODEL WRITER                              +
	// +                                                                       +
	// +-----------------------------------------------------------------------+
	
	File output("../../data/models/paliktnis.stmdl", MODE_WRITE);
	
	if (!output.is_open()) {
		std::cout << "Error writing to model file " << "../../data/models/paliktnis.stmdl" << std::endl;
		return 0;
	}

	std::cout << "MODEL packed! Writing to disk..." << std::flush;
	
	output.write_uint32(vertices.size());
	output.write_uint32(indices.size());
	output.write_uint32(materials.size());
	
	output.write_newline();
	
	for (auto& mat : materials) {
		output.write_name(mat.name);
		output.write_newline();
	}
	
	for (auto& vertex : vertices) {
		output.write_float32(vertex.pos.x);
		output.write_float32(vertex.pos.y);
		output.write_float32(vertex.pos.z);
		
		output.write_float32(vertex.nrm.x);
		output.write_float32(vertex.nrm.y);
		output.write_float32(vertex.nrm.z);
		
		output.write_float32(vertex.tex.x);
		output.write_float32(vertex.tex.y);
		
		output.write_float32(vertex.map.x);
		output.write_float32(vertex.map.x);

		output.write_newline();
	}
	
	for (auto& index : indices) {
		output.write_uint32(index.v1);
		output.write_uint32(index.v2);
		output.write_uint32(index.v3);
		
		output.write_uint32(index.mat);
		
		output.write_newline();
	}
	
	return 0;
	{
		File file("../../data/models/paliktnis.collmdl", MODE_WRITE);
		
		if (!file.is_open()) {
			std::cout << "Error writing to model file " << "../../data/models/paliktnis.COLLMDL" << std::endl;
			return 0;
		}
		
		for (const auto& brush : ent.brushes) {
			if (!brush.hull.size()) continue;
			
			file.write_name("cloud");
			file.write_uint64(brush.hull.size());
			
			file.write_newline();
			
			for (const auto& point : brush.hull) {
				file.write_float32(point.x);
				file.write_float32(point.y);
				file.write_float32(point.z);
				
				file.write_newline();
			}
		}
		
	}
	
	
	std::cout << "done!" << std::endl;
	
	return 0;
}